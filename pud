#!/usr/bin/perl

=head1 NAME

pud - up2date helper

=head1 DESCRIPTION
    
    pud will match the given perl regular expression to the 
    contents of the given url,then print out the regexp's groups.
    
=head1 OPTIONS
    
=over 4

=item B<-s URL>
  
    Match the regexp to the source of the given URL.
    
=item B<-p URL>
    
    Match the regexp to the parsed html.
    
=item B<-e REGEXP>
    
    The perl regular expression, with groups.
    Always use ' or " to enclose!
    
=item B<-t seconds>
    
    Timeout of the url's query. After the given seconds, the script 
    returns.
    The default timeout is 600.

=item B<-f format>
    
    A printf format string, for formating the output

=head1 BUILDING THE REGEXP

    The page is treated as a single line string, but
    regexp detects multiple lines(m//sm), so . matches \n, but ^,$ 
    match start and end of any line.

=head1 EXAPLES

pud -s http://frugalware.org -e "&nbsp;frugalware-(.*?)<.*fwclose"

pud -p http://frugalware.org/ -e '(\d+):(\d+) inc' -f "%d-%d"

=cut

use strict;
use warnings;
no warnings qw(uninitialized);
use LWP;
use LWP::UserAgent;
use Getopt::Std;
use HTML::Parser;

$Getopt::Std::STANDARD_HELP_VERSION = 1;
our $VERSION = "0.5";

sub HELP_MESSAGE(){
    print '
pud - up2date helper for Frugalware Linux
usage: pud -s|p URL -e PERL_REGEXP [-h] [-f format] [-t timeout]

';
}

my %opts;
getopts('s:p:e:ht:f:', \%opts);

HELP_MESSAGE() && exit if $opts{h};
do {HELP_MESSAGE; die '-p or -s ?';} if $opts{p} && $opts{s};
my $source = $opts{s} || $opts{p} || do {HELP_MESSAGE; die 'No source!';};
my $regexp = $opts{e} || do {HELP_MESSAGE; die 'No regexp!';};
my $timeout = $opts{t} || 600;      ## default time is 600s
my $format = $opts{f};

sub get_source{
    my $source = shift;
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $response = $ua->get($source);
    if ($response->is_success) {
	return $response->content if $opts{s};
	my $parsed;
	HTML::Parser->new(api_version => 3,
			  text_h =>[sub {$parsed .= shift}, 'dtext'],
			  )->parse( $response->content ) || die $!;
	return $parsed;
    }
    else {
	die $response->status_line;
    }
}

do {HELP_MESSAGE; die 'Unknown protocol!';} unless $source =~ m!^(?:ht|f)tp://!;

$regexp = qr/$regexp/sm;

if (get_source($source) =~ $regexp){
    if ($format){
	printf $format, $1,$2,$3,$4,$5,$6,$7,$8,$9;
    } else {
	print "$1$2$3$4$5$6$7$8$9\n";
    }
}
