#!/usr/bin/env python

__author__ = "Miklos Vajna <vmiklos@frugalware.org>, Marcus Habermehl <bmh1980de@yahoo.de>"
__version__ = "0.8.8"
__date__ = "Fri, 20 Apr 2007 21:43:12 +0200"
__copyright__ = "Copyright (c) 2007 Miklos Vajna, Marcus Habermehl"
__license__ = "GPL"

import tarfile, tempfile, shutil, os, stat, re, pacman, getopt, sys

from modulefinder import ModuleFinder

def usage():
	os.system("man chkdep")

def rmdupdeps(deps):
	depdeps = []
	newdeps = []
	i = pacman.db_getpkgcache(db)
	while i:
		pkg = pacman.void_to_PM_PKG(pacman.list_getdata(i))
		pkgname = pacman.void_to_char(pacman.pkg_getinfo(pkg, pacman.PKG_NAME))
		if pkgname in deps and pkgname not in ignorepkgs:
			j = pacman.void_to_PM_LIST(pacman.pkg_getinfo(pkg, pacman.PKG_DEPENDS))
			while j:
				dep = pacman.void_to_char(pacman.list_getdata(j)).split("<")[0].split(">")[0].split("=")[0]
				if dep not in depdeps:
					depdeps.append(dep)
				j = pacman.list_next(j)
		i = pacman.list_next(i)
	for i in deps:
		if i not in depdeps and i not in ignorepkgs:
			newdeps.append(i)
	return newdeps

def detect_owner(lib):
	global quiet
	if not len(lib):
		return
	if lib.find(fpmroot) == 0:
		return
	pkg = pacman.void_to_PM_PKG(pacman.list_getdata(pacman.pkg_getowners(lib)))
	owner = pacman.void_to_char(pacman.pkg_getinfo(pkg, pacman.PKG_NAME))
	if not owner and not quiet:
		print "WARNING: No package found containing %s!" % lib
	elif owner not in deps:
		deps.append(owner)

class Checks:
	def python(self, file):
		ftype = os.popen("file -b %s" % file).read().rstrip()
		if not "python script" in ftype and not file.endswith(".py"):
			return
		libs = []
		modules = []
		regex1 = r"import ([a-zA-Z0-9_\.]*)"
		regex2 = r"from ([a-zA-Z0-9_\.]*) import"
		fd = open(file, "r")
		for line in fd.readlines():
			module = str()
			if re.match(regex1, line):
				module = re.match(regex1, line).groups()[0].rstrip()
			elif re.match(regex2, line):
				module = re.match(regex2, line).groups()[0].rstrip()
			else:
				continue
			if not module:
				continue
			if not module in libs:
				modules.append(module)
		fd.close()

		for module in modules:
			mod_file = str()
			mod_repl = module.replace(".", "/")
			for path in sys.path:
				if os.path.isfile("%s/%s.py" % (path, mod_repl)):
					mod_file = "%s/%s.py" % (path, mod_repl)
					break
				elif os.path.isfile("%s/%s.so" % (path, mod_repl)):
					mod_file = "%s/%s.so" % (path, mod_repl)
					break
				elif os.path.isfile("%s/%s/__init__.py" % (path, mod_repl)):
					mod_file = "%s/%s/__init__.py" % (path, mod_repl)
					break
			libs.append(mod_file)
		return libs

	def elf(self, file):
		try:
			if not os.stat(file)[stat.ST_MODE] & stat.S_IXUSR:
				return
		except OSError:
			return
		libs = []
		sock = os.popen("ldd %s" % file)
		while True:
			i = sock.readline()
			if not i:
				break
			if i.find("=>") == -1:
				continue
			lib = re.sub(r".* => (.*) \(.*", r"\1", i.strip())
			if len(lib):
				libs.append(lib)
		sock.close()
		return libs

	def mono(self, file):
		dlls = []
		ret = []
		sock = os.popen("monodis --assemblyref runme.exe")

		while True:
			i = sock.readline()
			if not i:
				break
			if i.find("Name=") == -1:
				continue
			dll = i.strip().split('Name=')[1]
			if dll not in dlls:
				dlls.append(dll)
		sock.close()

		for i in dlls:
			sock = os.popen('MONO_LOG_LEVEL="debug" mono --aot runme.exe')
			while True:
				j = sock.readline()
				if not j:
					break
				if j.find(i) != -1:
					break
			sock.close()
			ret.append((re.sub(r".*'(.*)'.*", r"\1", j.strip())))
		return ret
	def perl(self, file):
		mods = []
		ret = []
		sock = open(file)
		while True:
			modules = []
			i = sock.readline()
			if not i:
				break
			if not re.match(r"^use [^ ]+::", i):
				continue
			lib = re.sub(r"^use ([^ ]+::[^ ]+)( |;).*", r"\1", i.strip())
			mods.append(lib)
		sock.close()
		for i in mods:
			sock = os.popen("perldoc -l %s" % i)
			ret.append(sock.readline().strip())
			sock.close()
		return ret

checks = Checks()

pacman.initialize("/")
db = pacman.db_register("local")
ignorepkgs = []
deps = []

dir = None
method="elf"
pkg = None
quiet = False

try:
	opts, args = getopt.getopt(sys.argv[1:], "d:p:qn:m:vi", ["dir=", "package=", "quiet", "ignore=", "method=", "version"])
except getopt.GetoptError:
	usage()
	sys.exit(1)

for opt, arg in opts:
	if opt in ("-d", "--dir"):
		dir = arg
	if opt in ("-p", "--package"):
		pkg = arg
	if opt in ("-q", "--quiet"):
		quiet = True
	if opt in ("-m", "--method"):
		method = arg
	if opt in ("-n", "--name"):
		ignorepkgs.append(arg)
	if opt in ("-v", "--version"):
		print "chkdep %s" % __version__
		sys.exit(0)

if not dir and not pkg:
	usage()
	sys.exit(1)

checker = getattr(checks, method)

if "FAKEROOTKEY" in os.environ.keys():
	ignorepkgs.append("fakeroot")

if pkg:
	fpmroot = tempfile.mkdtemp()
	fpm = tarfile.TarFile.open(pkg, "r:bz2")
	fpm.extractall(fpmroot)
	fpm.close()

if dir:
	fpmroot = dir

depfiles = []
for root, dirs, files in os.walk(fpmroot):
	for file in files:
		ret = checker(os.path.join(root, file))
		if ret:
			for i in checker(os.path.join(root, file)):
				if i not in depfiles:
					depfiles.append(i)
for i in depfiles:
	detect_owner(i)

if pkg:
	shutil.rmtree(fpmroot)

deps = rmdupdeps(deps)
print "depends=('" + "' '".join(deps) + "')"
