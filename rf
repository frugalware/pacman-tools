#!/usr/bin/perl -w

print "THIS PROGRAM IS UNDER TESTING! USE WITH CARE!\n";

=head1 NAME

    rf - RepomanFrontend

rf operates with actions, namely, Record, Cleanup, Push, Upload, cL.
If you don't specify non of these actioons, with the marked switch
(eg. for repoman cl it is -L), -RCPUL will be used.
it is trying to guess as many data as needed for the specified
actions, or you can pass them with non capital swithes.
Usually -f and -s are enough to do a whole upgrade.
    
=head1 DESCRIPTION

    
=head1 OPTIONS
    
=over 1

=item B<-h>

    Help

=for comment
=item B<-e>
repository gets extra.

=item B<-r>

    Specify the repository eg. extra
    if not given, default will be used.

=item B<-a>

    Architecture, default is i686.

=item B<-o>

    The directory of the repo, where the fpms are.
    Default is frugalware-$arch.

=item B<-p>

    Serverprefix, eg. 
    ftp://ftp.frugalware.org/pub/frugalware/frugalware-current/ 
    also this is the default.

=item B<-g>

    Group of the package, meaning the physical group, eg. the 
    /extra/devel/adevelpkg has devel group.

=item B<-n>

    Name of the package

=item B<-s>

    New sourcefile

=item B<-f>

    New packagefile

=item B<-q>

    Do not look for old source and package.
    Useful when you contribute a new package.

=item B<-v>

    Version of the distribution, default is current.

=item B<-d> 
    
    Delete the files given in -s and -f
    
=item B<-k>

    Answer yes to all questions.

=head1 CHANGES

=head2 0.4

    Action driven usage
    $arch fixes

=head2 0.3

    Sourcefile must contain 'tar'.
    Inform of use of -d
    asking done with readkey - no more enter hit

=head1 BUGS

    Report bugs, patches, comments, patches and 
    funny quotes in your signature to
    <frugalware-devel@frugalware.org>

=head1 AUTHOR

    Zsolt Szalai

=head1 COPYRIGHT

    rf may be copied and modified under the terms of the 
    GNU General Public License v2

=cut

use strict;
no warnings qw(uninitialized);

use Data::Dumper;
use LWP::Simple;
use Cwd;
use Getopt::Std;
use Term::ReadLine;
use IO::File;
eval {require Term::ReadLine::Gnu}; die 'Please install perl-term-readline-gnu!' if $@;
eval {require Term::ReadKey}; die 'Please install perl-term-readkey!' if $@;
import Term::ReadKey;

$Getopt::Std::STANDARD_HELP_VERSION = 1;
our $VERSION = "0.4";

sub HELP_MESSAGE(){
  print <<END
	rf [-RCPUL] [-s 'source1 source2 ...'] [-f packagefile] [-d] [-q] [-k] [-n name]
END
}

sub contents {
    my $sfh = IO::File->new( "< $_" );
    local $/ = undef;
    my $cont = $sfh->getline;
    $sfh->close;
    return $cont;
}

# run from the packages darcs dir!
# -h help; -e extrarepo!overrides -r; -r repo; -a arch/; -R repodir; -p serverprefix; 
#-g group*!physical category;  -n pkgname*; -s sourcefile* -f fpm* -v version!eg. current -d del the files
# -k noask -q dont look for old files on server
# / elsre nem csinlom meg; * kiszedheti mashonnan is eros konnyites
my %opts;
getopts('her:a:o:p:g:n:s:f:v:dqokt:l:RCPUL', \%opts);

HELP_MESSAGE && die if $opts{h};

$opts{R}=$opts{C}=$opts{P}=$opts{U}=$opts{L} = 1 unless $opts{R}|| $opts{C}||$opts{P}||$opts{U}||$opts{L};

my ($distrib,$version,$repo,$arch, $repodir, $serverprefix, $group, $pkgname, $pkgfile, $noask) =
    ('frugalware',$opts{v},undef,$opts{a}, $opts{o}, $opts{p}, $opts{g}, $opts{n}, $opts{f}, $opts{k});
my @sourcefiles = split ' ', $opts{'s'};
my ($pkgver, $pkgrel);

sub msystem{
    system @_;
    warn 'Failed to execute!' if $? == -1;
}

sub getcommand{
    my $str = shift;
    my $term = new Term::ReadLine 'getcommand';
    return $term->readline('>',$str)
}

sub ask{
    my $str = shift;
    return 'y' if $noask;
    print "$str ";
    my $key;
    ReadMode(4);
    $key = ReadKey();
    ReadMode(0);
    print "$key\n";
    return $key;
}

sub apply{
    my $comm = shift;
  APP:
    if ((my $an = ask "$comm\n Is this ok? [ygq?]") =~ /^y|^$/i){
	msystem $comm;
    } elsif ($an =~ /^g/i){
	msystem getcommand($comm);
    } elsif ($an =~ /^q/i){
	exit;
    } elsif ($an =~ /^\?/){
	print "y: applay command\ng: give a new command\nq: quit\n\n";
	undef $an;
	goto APP;
    }
    print "\n";
}

$repo = '' || $opts{r};
$repo = 'extra' if getcwd =~ m!/extra/!;

$version = 'current' unless $version; #no need :)
$arch = qx/arch/ and chomp $arch unless $arch;

$repodir = "$distrib-$arch" unless $repodir;
$serverprefix = "ftp://ftp.$distrib.org/pub/$distrib/$distrib-$version/";

unless ( ($group) = getcwd =~ m!.*/(.*?)/[^/]*\Z! ){
    $group = $opts{g};
}
HELP_MESSAGE && die 'No physical group given!' unless $group;

unless (($pkgname) = $pkgfile =~ /^(.*)-.*?-.*?-.*?fpm\Z/){
    $pkgname = $opts{n};
}
($pkgname) = getcwd =~ m!/([^/]*)\Z! unless $pkgname;
HELP_MESSAGE && die 'Can not determine pkgname!' unless $pkgname;

if ($pkgname){
    ($pkgver,$pkgrel) = $pkgfile =~ /^.*-(.*?)-(.*?)-.*?fpm\Z/
} else {  #get them from Frugalbuild
    my $buildscript = contents 'FrugalBuild';
    $pkgver = $buildscript =~ /^pkgver=(\S*)/m;
    $pkgrel = $buildscript =~ /^pkgrel=(\S*)/m;
}
$pkgver = $opts{t} if $opts{t};
$pkgrel = $opts{l} if $opts{l};

sub getoldsource{
    my ($url,$sourcefile)= @_;
    my ($sn) = $sourcefile =~ /(.*)-/;
    if (get($url) =~ /(\Q$sn\E.*?tar.*?)\s/) {
	return $1;
    }
    return 0;
}

sub getoldfpm{
    my ($url,$pkgname)= @_;
    if (get($url) =~ /(\Q$pkgname\E-[^-]*?-[^-]*?-[^-]*?fpm)\s/) {
	return $1;
    }
    return 0;
}

sub Record{
  print "Recording your improvements\n";
  HELP_MESSAGE && die 'Can not determine pkgver!' unless $pkgver;
  HELP_MESSAGE && die 'Can not determine pkgrel!' unless $pkgrel;
  apply "darcs record --edit-long-comment -m '$pkgname-$pkgver-$pkgrel-$arch' ." . ($noask? ' -a' : '');
}

sub Push{
  print "Pushing the patch\n";
  apply "darcs push --match 'name $pkgname'" . ($noask? ' -a' : '');
}

sub Upload{
  print "Uploading source and binary package\n";
  print "Nothing to do, that's fine!\n\n" unless @sourcefiles && $pkgfile;
  for my $sourcefile (@sourcefiles){
    apply "repoman up $sourcefile $repo/source/$group/$pkgname/" if $sourcefile;
  }
  apply "repoman up $pkgfile $repo/$repodir/" if $pkgfile;
}

sub cL{
  print "Generating ChangeLog\n";
  $repo.='/' if $repo;
  apply "arch=$arch repoman cl $repo$group/$pkgname";
}

sub Cleanup{
  unless ($opts{'q'}){
    print "Cleanup on server\n";
    my $repo_=$repo . '/' if $repo;
    print "Nothing to do, that's fine!\n\n" unless @sourcefiles && $pkgfile;
    if (@sourcefiles){
      my (@indarcs) = get("$serverprefix/_darcs/current/$repo_/source/$group/$pkgname/") =~ /\s(\S+)$/msg;
      my (@inrepo) = get("$serverprefix/$repo_/source/$group/$pkgname/") =~ /\s(\S+)$/msg;
      for my $ir (@inrepo){
	unless(scalar grep(/\Q$ir\E/, @indarcs)){
	  apply "repoman del $repo/source/$group/$pkgname/$ir";}}}
    if ($pkgfile){
      if( my $oldf = getoldfpm("$serverprefix/$repo/$repodir/",$pkgname) ){ 
	apply "repoman del $repo/$repodir/$oldf";}}}
}

print "What have you been hacking today?\n";
unless ((my $what = qx"darcs what -s .") =~ /\QNo changes!\E/){ 
  print $what;
  exit unless (my $an = ask 'Have you checked your package? Everything is ok with it?') =~ /^y|^$/i;
} else {print "Nothing!\n"}


Record if $opts{R};
Cleanup if $opts{C};
Push if $opts{P};
Upload if $opts{U};
cL if $opts{L};

if ($opts{d}){ #delete source & fpm        doesnt ask it, -d is not default!
    for my $sourcefile (@sourcefiles){
	print "Deleting source file $sourcefile\n";
	unlink $sourcefile if $sourcefile;
    }
    print "Deleting package $pkgfile\n";
    unlink $pkgfile if $pkgfile;
}

__END__

ok, here's the plans:

ACTIONS:
        -R darcs record - pkgname, ver, rel, arch
        -C cleanup - a directory, but repo, category, pkgname enough   !sources, pkgs!
        -P darcs push - nothing, but provide options(in case of darcs mv)
        -U upload - repo, group, etc no prob. !sources, pkgs!
        -L cl repo, gproup pkgname


